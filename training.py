import sysimport osimport csvimport reimport datetime"""This program trains brain with training data.The brain can then be used for classification by classicitaion.py.Usage:python training.py <csv_training_file>It will read training file, and write a certain brain file (brain.txt) to current directory.The brain file will be overwritten at each execution of this script.This script requires write access current directory.Failure to give valid argument will result in halt of execution withhelpful information displayed."""# file path to the brain filebrain_file='brain.txt'def read_csv_data(tfile):    '''    It read csv file, strips it title and return in rows of columns.    @param tfile Path to csv file.    @return Rows of columns of csv data    '''    rows = []    with open(tfile, 'rU') as csvfile:        reader = csv.reader(csvfile, delimiter=',')        for row in reader:            rows += [row]    rows = rows[1:]    return rowsclass DTree:    '''    This class responsible for the entire decision process.    '''    def __init__(self):        '''        Initialization        '''        self.items = {}        self.predict = Predict()            def train(self, data):        '''        Train DTree with data contains:         'Row ID','#water_source','#water_tech','Water Source Type'        @param data(List) List contain 4 column of each train file line        '''        a, b, v = (data[1], data[2], data[3])        if not a in self.items:            self.items[a] = DTree()        self.items[a].train_b(b, v)        self.predict.train(a, v)            def train_b(self, b, v):        '''        Train DTree for collumn3 i.e. water tech        @param b Contents of column3        @param v Supposed output value        '''        if not b in self.items:            self.items[b] = {}        if not v in self.items[b]:            self.items[b][v] = 0        self.items[b][v] += 1        self.predict.train(b, v)            def refine(self):        '''        Refine DTree from multiple value.        It choose the best value from statistics.        '''        for x in self.items.values():            x.refine_b()        self.predict.refine()            def refine_b(self):        '''        Refine DTree from multiple value, for 3rd column i.e water tech        It choose the best value from statistics.        '''        for t in self.items.keys():            item = self.items[t]            if len(item.keys()) > 1:                total = 0                best = item.keys()[0]                for x in item.keys():                    total += item[x]                    if item[x] > item[best]:                        best = x                self.items[t] = {best: item[best]/total}            else:                item[item.keys()[0]] = 1.0        self.predict.refine()            def save(self, path):        '''        Save the entire decision system to brain file.        @param path Path to brain file.        @except Possible exception if writing file failed.        '''        with open(path, 'w') as fout:            for x in self.items.keys():                fout.write('a->'+x+'\n')                self.items[x].save_b(fout)            self.predict.save(fout,'')                def save_b(self, fout):        '''        Save DTree for 3rd column to fout.        @param fout An already opened for writing output file        '''        for x in self.items.keys():            fout.write('   b->'+x+'->'+self.items[x].keys()[0]+'->'+str(self.items[x].values()[0])+'\n')            self.predict.save(fout, '   ')                def open(self, path):        '''        Open a brain file.        @param path Path to brain file.        @except Possible exception if reading file failed.        '''        lines = []        with open(path, 'r') as fin:            lines = fin.readlines()        self.items = {}        item = {}        mode = 1        for line in lines:            sline = line.strip()            parts = re.split('->', sline)            if parts[0] == 'a':                self.items[parts[1]] = DTree()                item = self.items[parts[1]]            elif parts[0] == 'b':                name, value, freq = (parts[1], parts[2], float(parts[3]))                item.items[name] = {value: freq}            elif parts[0] == 'p':                if len(parts) == 2:                    mode = int(parts[1])                else:                    if line.startswith('   '):                        item.predict.parse(mode, parts[1:])                    else:                        self.predict.parse(mode, parts[1:])                            def query(self, data, logic=None):        '''        Query DTree with data (column 1, 2, 3), i.e 'Row ID','#water_source','#water_tech'.        @param data(List) Contents of column 1, 2, 3        @param logic(optional) If given the system decision logic will be padded here.        @return The prediction value or 'Null'        '''        if logic != None:            logic += ['Dtree#query#'+str(data)]        a, b = (data[1], data[2])        if not a in self.items:            return self.predict.query(a, logic) or 'Null'        else:            q = self.items[a].query_b(b, logic)            if q == None:                q = self.predict.query(a, logic)                if q == None and a != '':                    return self.query(['','',a], logic)                return q or 'Null'            return q or 'Null'                def query_b(self, b, logic=None):        '''        Query DTree with column 3, i.e water tech.        @param b Text in column 3 (water tech)        @param logic(optional) If given the system decision logic will be padded here.        @return The prediction value or None        '''        if logic != None:            logic += ['Dtree#query_b#'+str(b)]        if not b in self.items:            return self.predict.query(b, logic)        else:            return self.items[b].keys()[0]class Predict:    '''    This module responsible for prediction system in case no exact match    is found on the decision tree.    '''    predef = { #predefined output choice        'Borehole or tubewell':True,        'Null':True,        'Piped into public tap or basin':True,        'Piped into yard/plot':True,        'Protected dug well':True,        'Protected spring':True,        'Public tap or standpipe':True,        'Rainwater':True,        'Surface water':True,        'Unprotected dug well':True,        'Unprotected spring':True    }    def __init__(self):        '''        Initialization        '''        self.items = {}            def train(self, key, value):        '''        Train this prediction system with input key and output value.        @param key Input key        @param value The suppossed result of prediction system        '''        parts = self.generate_parts(key)        items = self.generate_items(parts)        for length in items.keys():            self.items[length] = self.items[length] if length in self.items.keys() else {}            sitems = self.items[length]            for x in items[length]:                sitems[x] = sitems[x] if x in sitems.keys() else {}                sitems[x][value] = sitems[x][value] + 1 if value in sitems[x].keys() else 1                    def generate_parts(self, key):        '''        Given a certain key/name/label, it will extract possible useful token.        @param key Key/Name/Label that come from colum2 and column3 of csv training data.        @return List of generated parts        '''        key = key.split('(')[0].strip().lower()        parts = re.split(' system| use| with | for | of | on | or |/|-|\|| ', key)        parts = [x for x in parts if len(x)>0]        return sorted(list(set(parts)))            def generate_with_length(self, parts, length):        '''        Generate name with certain token length from parts.        @param parts(List) List contains name parts        @param length Length of token to create        @return List of generated names        '''        if length == 0:            return []        if length == 1:            return parts        items = []        for x in range(len(parts)-length+1):            items += [parts[x]+' '+y for y in \                self.generate_with_length(parts[x+1:], length-1) if len(y)>0]        return items            def generate_items(self, parts):        '''        Given parts of name, it will generate items with length 1, 2, 3 tokens.        @param parts(List) List of name parts        @return List of generated names        '''        return {1: self.generate_with_length(parts, 1), \            2: self.generate_with_length(parts, 2), \            3: self.generate_with_length(parts, 3)}                def refine(self):        '''        Refine items with possible multiple values.        It choose the best one and remove the rest.        (p1, ..., p3) is parts of name        (p1, ..., p3) -> value1 -> {x}        '''        for length in self.items.keys():            sitems = self.items[length]            for t in sitems.keys():                item = sitems[t]                if len(item.keys()) > 1:                    total = 0                    best = item.keys()[0]                    for x in item.keys():                        total += item[x]                        if item[x] > item[best]:                            best = x                    sitems[t] = {best: item[best]*1.0/total}                else:                    item[item.keys()[0]] = 1.0                        def save(self, fout, prefix):        '''        Save this predict system to file with certain prefix.        @param fout An already opened for writing output file        @param prefix Prefix for each line        '''        for length in self.items:            fout.write(prefix+'p->'+str(length)+'\n')            sitems = self.items[length]            for x in sitems.keys():                fout.write(prefix+'p->'+x+'->'+sitems[x].keys()[0]+'->'+str(sitems[x].values()[0])+'\n')                    def parse(self, mode, parts):        '''        Given a splitted parts of brain line, this will parse and feed it to prediction system.        @param mode Mode to run, it can be 1,2,3 tokens        @param parts(List) Splitted parts of a line from brain file.        '''        self.items[mode] = self.items[mode] if mode in self.items.keys() else {}        sitem = self.items[mode]        name, value, freq = (parts[0], parts[1], float(parts[2]))        sitem[name] = {value: freq}            def query(self, name, logic=None):        '''        Query Predict information for a certain label/name.        @param name Label/name to query        @param logic Output of decision logic used in determining return value.            This is useful for debugging.        @return String indicating water source type        '''        if logic != None:            logic += ['Predict#query#'+str(name)]        for x in Predict.predef:            if name.startswith(x):                return x        name = name.lower()        if name.find('well')>=0 and name.find('dug')>=0:            if name.find('unprotected')>=0:                return 'Unprotected dug well'            elif name.find('protected')>=0:                return 'Protected dug well'        items = self.generate_items(self.generate_parts(name))        best = None        for length in [3, 2, 1]:            if not length in self.items.keys():                continue            sitems = self.items[length]            for x in items[length]:                if x in sitems:                    if best == None or sitems[best].values()[0] < sitems[x].values()[0]:                        best = x            if best != None:                if logic != None:                    logic += ['best predict:=>'+best]                return sitems[best].keys()[0]        return None            def print_items(self):        '''This will print all items. Useful for debugging.'''        for x in self.items.keys():            print x+'=>'+','.join([k+':'+str(self.items[x][k]) for k in self.items[x].keys()])if __name__ == '__main__':    tfile = ''    # parameter checks    if len(sys.argv) == 2:        tfile = sys.argv[1]    if tfile == '':        print "Usage:"+sys.argv[0]+" <csv_train_file>"        exit(0)            tree = DTree()    rows = []    try:        # load train file        sys.stdout.write('Loading train file ('+sys.argv[1]+') in: ')        stime = datetime.datetime.now()        rows = read_csv_data(tfile)        print str(datetime.datetime.now()-stime), 'SUCCESS'    except:        print str(datetime.datetime.now()-stime), 'FAILED'        exit()        try:        # train decision tree        sys.stdout.write('Training in: ')        stime = datetime.datetime.now()        for r in rows[:int(len(rows)/2)]:            tree.train(r)        tree.refine()        print str(datetime.datetime.now()-stime), 'SUCCESS'    except:        print str(datetime.datetime.now()-stime), 'FAILED'        exit()        try:        # create brain        sys.stdout.write('Create brain ('+brain_file+') in: ')        stime = datetime.datetime.now()        tree.save(brain_file)        print str(datetime.datetime.now()-stime), 'SUCCESS'    except:        print str(datetime.datetime.now()-stime), 'FAILED'        exit()